# Ch 5. 책임과 메세지

✅ 객체의 역할과 책임은 명확해야함

- 역할과 책임이 명확하지 않다면 → 협력에 문제 발생

# 1. 자율적인 책임

## 📌 설계의 품질을 좌우하는 책임

✅ 협력 과정에서 객체는 책임을 수행하기 위해 자율적으로 판단하고 행동함

- 자율적인 객체 : 스스로 의지와 판단에 따라 맡은 책임을 수행하는 객체

✅ 객체에게 적절한 책임 → 객체의 자율성 ↑ → 협력의 유연성, 단순성 ↑ → 앱의 품질 ↑

 

## 📌 자신의 의지에 따라 증언할 수 있는 자유

✅ 객체에게 할당되는 책임이 자율적이어야 함

- 그래야 객체가 책임을 자율적으로 수행할 수 있음

📖 앨리스 이야기 : 모자 장수의 증언 방식

- 모자 장수에게 할당되는 책임 : `증언하라`
- 따라서 모자 장수가 증언하는 방식은 자율적
- 만약 왕이 `~어떻게~ 증언하라` 라고 말했다면 모자 장수는 자율적인 책임 수행이 어려움

## 📌 너무 추상적인 책임

✅ 협력 의도를 명확하게 표현하지 못할 정도로 추상적인 책임도 문제가 됨

 

📖 앨리스 이야기 : 모자 장수의 증언 방식

- 모자 장수에게 `설명하라` 라는 너무 추상적인 책임이 할당됐다면
- 무엇을 말해야하는지 명확하지 못함

✅ 책임은 협력의 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야함

## 📌 ’어떻게’가 아니라 ‘무엇을’

✅ 자율적인 책임의 특징

- 어떻게(how) 가 아니라 무엇(what)을 해야하는지 설명함
- ex. 모자 장수에게 할당된 책임(증언하라)는 무엇을 해야하는지만 결정되어 있음
- → 그래서 모자 장수는 자율적으로 책임 수행 가능

## 📌 책임을 자극하는 메세지

✅ 객체가 할당된 책임을 수행하도록 만드는 것

- 외부에서 전달되는 요청(메세지)
- ∵ 객체는 요청을 수신할 때만 행동하므로

# 2. 메세지와 메서드

## 📌 메세지

✅ 협력하기 위한 유일한 소통 방법 : 메세지

✅ 메세지 전송의 구성

- 수신자: 메세지 이름 : (인자)

| 메세지 전송 요소 | 예시 |
| --- | --- |
| 수신자 | 모자 장수 |
| 메세지 이름 | 증언하라 |
| 인자 | 어제, 왕국 |

✅ 수신자가 메세지를 처리한다는 것의 의미

- 해당 메세지의 행동을 수행할 책임이 있다는 것
- ∴ 메세지의 모양이 객체가 수행할 책임의 모양을 결정함

✅ 객체의 외부, 내부를 구분하는 기준 : 메세지

- 외부 : 객체에게 제공하는 메세지
- 내부 : 해당 메세지를 처리하는 영역
- ∵ 수신자는 책임을 수행하는 방법을 변경해도 됨, 메세지에 맞는 책임만 수행하면 됨

## 📌 메서드

✅ 메서드

- 메세지를 처리하기 위해 내부적으로 선택하는 방법

📖 앨리스 이야기 : 모자 장수의 메세지, 메서드

| 항목 | 예시 |
| --- | --- |
| 메세지 | 증언하라 |
| 메서드 | 모자 장수가 내부적으로 선택하는 증언 방법 |

✅ 수신자의 메세지 처리 과정

1. 메세지 수신

2. 해당 메세지를 처리할 수 있는지 확인

3. 처리할 수 있다면 → 메세지를 처리하기 위한 메서드 선택

✅ 객체지향 언어와 다른 언어를 구분하는 핵심 특징

- 메세지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 것

## 📌 다형성

✅ 다형성

- 서로 다른 타입의 객체가 같은 메세지를 수신할 경우, 서로 다른 메서드로 메세지를 처리할 수 있는 매커니즘

✅ 같은 메세지라도 이를 처리하는 방식은 객체마다 다를 수 있음

- ∵ 메세지는 무엇이 실행될 지 말하지만, 메세지를 어떻게 처리할지는 수신자의 자유

📖 앨리스 이야기 : 모자 장수, 요리사, 앨리스의 증언

- `증언하라`라는 메세지를 받아도 각 객체는 증언하는 방식이 다를 수 있음
- 같은 메세지에 대해 서로 다른 메서드로 처리하는 것 ⇒ 다형성

✅ 객체들이 다형성을 만족한다는 것의 의미

- 객체들이 같은 책임을 공유하고 있다는 것

✅ 다형성에서는 송신자 관점이 중요함

- 수신자가 메세지를 어떻게 처리하더라도, 송신자 입장에선 모두 동일한 책임을 수행하는 것
- 따라서 송신자는 다형적 수신자를 구분할 필요가 없음
- ex. 클라이언트는 서버 내부 구현을 몰라도 됨 → ∴ 서버의 내부 처리 방식이 변경돼도 클라이언트 코드 변경 없음

✅ 다형성과 대체 가능성

- 동일한 역할을 수행할 수 있는 객체들은 서로 대체 가능
- 어떤 수신자가 메세지를 처리하더라도 책임만 수행하면 되므로
- 다형성은 객체의 대체 가능성으로 → 설계의 유연성 ↑, 재사용성 ↑

✅ 다형성은 수신자의 종류를 캡슐화함

- 다형성을 사용하면 송신자는 수신자의 종류를 몰라도 메세지 전송 가능
- ex. `증언하라` 메세지는 `증인` 역할이면 어떤 객체든 수신 가능

✅ 객체지향에서 다형성을 달성하는 방법

- 송신자-수신자 간의 객체 타입에 관한 결합도를 메세지에 대한 결합도로 낮추기

✅ 다형성으로 협력이 유연하고 확장 가능한 구조가 됨

## 📌 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

✅ 송신자는 수신자의 정보를 조금만 알아도 협력이 가능

- ex. 왕은 수신자가 `증언하라` 메세지를 이해할 수 있다는 사실만 알고 협력에 참여
- 이는 유연성, 확장 가능성, 재사용성과 연결됨

1️⃣ 협력의 유연성

- 송신자는 수신자가 메세지만 이해하면 됨
- 따라서 수신자가 다른 타입으로 변경돼도 괜찮음
- 이는 수신자를 변경해도 송신자에 대한 파급효과 없이 유연하게 변경 가능함을 의미

2️⃣ 협력의 확장 가능성

- 송신자에게 영향을 미치지 않고 수신자 교체 가능
- 따라서 역할에 맞는 새로운 수신자를 계속 추가할 수 있음

3️⃣ 협력의 재사용성

- 송신자, 수신자 역할에 맞는 객체면 협력 재사용 가능
- ex. 다른 객체라도 `재판관`, `증인` 역할만 수행 가능하면 `재판`이라는 협력은 재사용 가능

## 📌 송신자와 수신자를 약하게 연결하는 메세지

✅ 설계를 유연하고, 확장 가능하고 재사용 가능하게 만드는 것

- 메세지

✅ 송신자와 수신자는 메세지로만 연결되어 있음

- 즉, 송신자는 수신자가 메세지를 어떻게 처리하는지는 모름
- 이러한 두 객체의 낮은 결합도가 설계의 유연성, 확장 가능성, 재사용성을 높임
- 따라서 설계의 품질을 높이려면 좋은 메세지를 골라야함

# 3. 메세지를 따라라

## 📌 객체지향의 핵심, 메세지

✅ 객체지향의 핵심은 메세지

- 객체지향 앱은 클래스로 구현되지만 메세지를 통해 정의됨
- 앱을 살아 있게 만드는 것은 클래스가 아니라 메세지를 주고 받는 객체
- 클래스는 객체의 속성과 행위를 담는 틀에 불과함
- ∴ 앱을 설계할 때 객체의 속성과 행위를 먼저 구분하고 → 그 후에 클래스를 정의해야함

✅ 객체보다 메세지가 중요함

- 객체의 정의(상태와 메서드)보다 협력이라는 문맥에서 메세지에 집중해야함
- 메세지가 아니라 데이터를 중심으로 객체를 설계하면 → 객체의 자율성 ↓
- ∵ 객체 내부 구조를 객체의 정의로 포함시키면 외부에서 접근 가능하므로
- 객체의 자율성을 위해 객체를 캡슐화해야함

✅ 좋은 객체지향 설계는 다음을 중심으로 협력을 구성하는 것

- 객체가 어떤 메세지를 전송할 수 있는지
- 객체가 어떤 메세지를 이해할 수 있는지

✅ 객체가 메세지를 선택하는 것이 아니라 메세지가 객체를 선택하게 설계해야함

## 📌 책임 주도 설계 다시 살펴보기

✅ 책임 주도 설계

- 책임을 수행하기 위해 협력하는 객체를 이용해 시스템을 설계하는 방법
- 어떤 객체가 책임을 수행하다가 다른 객체와 협력해야함

✅ 책임 주도 설계에서 `앱의 기능 = 시스템의 책임`

- → 이 책임을 객체의 책임으로 할당
- → 객체가 책임을 수행하기 위해 다른 객체가 필요하면 메세지를 결정
- → 메세지를 결정한 후 이를 처리할 수 있는 객체 선택

✅ 메세지가 수신자의 책임을 결정함

- 수신자도 다른 객체의 도움이 필요하면 메세지 전송 가능

## 📌 What/Who 사이클

✅ What/Who 사이클

- 행동을 먼저 결정한 뒤 → 누가 수행할지 결정하는 것
- 이는 책임 주도 설계의 핵심

✅ 메세지가 객체의 책임을 결정함

1. 협력에 필요한 메세지 결정

2. 수신자 선택

3. 수신된 메세지가 객체의 책임 수행

✅ What/Who 사이클과 메세지

1. 협력에 필요한 메세지 결정

2. 메세지를 수신할 객체 결정

## 📌 묻지 말고 시켜라

✅ 메세지를 먼저 결정하고 이에 맞는 객체를 선택하는 방식 ⇒ 인터페이스 중심 설계로 이어짐

✅ 메세지를 먼저 결정하면 캡슐화 ↑

- 메세지를 먼저 결정하면, 결정 시점에 수신자를 모름
- ∴ 수신자 내부도 모름 ⇒ 캡슐화 ↑

✅ 묻지 말고 시켜라 방식

- 자신이 전송한 메세지를 잘 처리할 것을 맏고 메세지를 전송하는 방식
- 이 방식은 객체의 자율성을 강조
- 즉, 객체는 다른 객체에게 간섭하지 않고 스스로 메세지를 어떻게 처리할지 결정을 내려야함
- 그러면 객체의 자율성 ↑ 캡슐화 ↑ 유연성 ↑(∵ 결합도 ↓)

✅ 묻지 말고 시켜라 방식의 유연성

- 이 방식은 메세지가 어떻게 보단 무엇을 해야하는지 요청하는
- → 그러면 객체 인터페이스 크기가 감소됨
- 이는 외부에서 해당 객체에 의존해야하는 부분이 작다는 것을 의미
- 따라서 송신자-수신도의 결합도가 낮아져 유연해짐

## 📌 메세지를 믿어라

✅ 메세지를 수신할 수만 있다면 → 수신자의 타입은 무관함

- 수신자의 타입보다 메세지를 처리할 수 있는지가 중요함
- 수신자가 다양한 타입이 될 수 있으므로 유연성 ↑, 확장성 ↑
- 다양한 객체가 협력에 참여하므로, 협력 재사용성 ↑

# 4. 객체 인터페이스

## 📌 인터페이스

✅ 인터페이스의 특징 3가지

1. 인터페이스 사용법을 익히면 내부 구조나 동작 방식을 몰라도 대상을 조작 가능

2. 인터페이스는 변경하지 않고 내부를 변경하는 것은 인터페이스 사용자에게 영향 없음

3. 대상이 변경돼도 동일한 인터페이스를 제공하면 상호 작용 가능

✅ 협력에서 인터페이스

- 객체의 인터페이스만 알면 다른 객체의 내부를 몰라도 협력 가능
- 인터페이스만 유지되면 다른 객체의 내부가 변경되거나 다른 객체로 대체돼도 인터페이스 사용자에게 영향 없음

## 📌 메세지가 인터페이스를 결정한다

✅ 객체 간 상호작용하는 유일한 방법 : 메세지

- ∴ 객체의 인터페이스 = 객체가 수신할 수 있는 메세지 목록
- 객체가 수행하는 메세지가 객체 공용 인터페이스의 모양을 결정

## 📌 공용 인터페이스

✅ 공개 범위에 따른 인터페이스 종류

|  | 공용 인터페이스 | 사적인 인터페이스 |
| --- | --- | --- |
| 공개 범위 | 외부 | 내부만 접근 가능 |
| 송신자 | 외부 객체 | 객체 자신 |
| 접근 방법 | 메세지 | 메세지 |

📖 증인 역할의 공용 인터페이스

- `증인석에 입장하라`, `증언하라`

## 📌 책임, 메세지, 그리고 인터페이스

✅ 책임

- 협력에 참여하는 객체의 책임은 자율적이어야함
- 즉, 객체 스스로 책임을 수행하는 방법을 결정

✅ 메세지

- 객체의 인터페이스는 객체가 수신할 수 있는 메세지 목록
- 메세지를 수신하면 적절한 책임을 수행함
- 메서드 : 메세지를 수신했을 때 책임을 수행하는 방법

✅ 인터페이스

- 객체가 외부로부터 메세지를 받기 위한 통로
- 메세지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확하게 분리함

# 5. 인터페이스와 구현의 분리

## 📌 객체 관점에서 생각하는 방법

✅ 객체지향적 사고 방식을 이해하기 위한 원칙 3가지

1. 좀 더 추상적인 인터페이스

2. 최소 인터페이스

3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

1️⃣ 좀 더 추상적인 인터페이스

- 추상적인 메세지가 객체의 자율성 ↑

2️⃣ 최소 인터페이스

- 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출 X
- 메세지를 객체보다 먼저 설계하면 최소 인터페이스를 얻게됨
- 협력에 필요한 메세지만 공용 인터페이스에 포함

3️⃣ 인터페이스와 구현 간에 차이가 있다는 점을 인식

- 객체의 외부와 내부를 명확하게 분리하는 것은 중요함
- 객체의 외부 : 공용 인터페이스
- 객체의 내부 : 구현

## 📌 구현

✅ 구현(implementation)

- 객체의 내부 구조와 작동 방식
- 객체를 구성하지만 공용 인터페이스에 포함되지 않은 모든 것

✅ 구현의 종류

- 객체의 상태 표현 방식
- 메서드를 구성하는 코드

## 📌 인터페이스와 구현의 분리 원칙

✅ 인터페이스와 구현의 분리 원칙

- 구현(객체의 상태, 메서드 구현부 등)을 변경해도 외부에 영향이 미치면 안됨
- 인터페이스를 수정할 때만 외부에 영향이 미쳐야함

✅ 인터페이스와 구현의 분리 원칙이 중요한 이유

- SW 변경을 쉽게 관리하기 위함
- 변경해도 외부에 영향이 없는 곳(구현)을 구분하면 변경이 쉬움

✅ 인터페이스와 구현의 분리 원칙과 자율성

- 변경해도 외부에 영향이 없다는 것은 객체의 자율성이 높아짐을 의미

✅ 캡슐화

- 이 원칙을 수행하기 위한 객체 설계 방법

## 📌 캡슐화

✅ 캡슐화

- 객체의 자율성을 위해 구현을 외부로부터 감추는 것
- 정보 은닉(information hiding)이라고도 부름

✅ 객체지향 세계에서 2가지 캡슐화

1. 상태와 행위의 캡슐화

2. 사적인 비밀의 캡슐화

1️⃣ 상태와 행위의 캡슐화

- 상태와 행동을 하나로 묶고, 외부에서 반드시 접근해야한 하는 행동을 공용 인터페이스로 노출

2️⃣ 사적인 비밀의 캡슐화

- 사적인 비밀 ≒ 변경이 자주 일어나는 부분

✅ 객체의 내부와 외부를 구분하면 객체의 자율성 ↑ ⇒ 설계가 단순하고 유연하고 변경이 쉬워짐

# 6. 책임의 자율성이 협력의 품질을 결정한다

✅ 책임의 자율성 ↑ ⇒ 협력의 단순성 ↑, 유연성 ↑

✅ 자율적인 책임 ⇒ 협력의 단순성 ↑

- 자율적인 책임은 책임을 어떻게 수행할지 세부 사항은 무시하는 것
- 세부사항이 무시되면 책임의 의도가 명확하게 표현됨 + 협력이 단순하고 이해하기 쉬워짐

✅ 자율적인 책임 ⇒ 객체의 내부와 외부를 분리

- 자율적인 책임은 책임을 어떻게 수행할지 세부 사항은 무시하는 것
- 이는 책임의 내부가 캡슐화되는 것 → 내부와 외부를 분리

✅ 자율적인 책임 ⇒ 내부를 변경해도 외부에 영향 X

- 책임 수행 방법을 변경해도 협력에는 영향이 없음
- 변경의 파급효과가 객체 내부로 캡슐화 → ∴ 객체 간 결합도 ↓

✅ 자율적인 책임 ⇒ 협력의 대상을 다양하게 선택하는 유연성 제공

- 책임만 수행하면, 누가 책임을 수행하더라도 괜찮음
- 이는 협력의 대상에 대한 유연성 ↑
- 설계가 유연해지고 재사용성이 높아짐

✅ 자율적인 책임 ⇒ 객체의 역할을 이해하기 쉬움

- 책임 수행 방법은 표현되지 않음 → ∴ 객체의 존재 이유를 명확하게 표현
- 객체의 응집도를 높은 상태로 유지하기 쉬워짐