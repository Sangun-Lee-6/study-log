# 섹션 8. 자바 메모리 구조와 static

# 1. 자바 메모리 구조

✅ 메서드 영역

- 프로그램을 실행하는데 필요한 공통 데이터를 관리
- 프로그램의 모든 영역에서 공유

✅ 메서드 영역에 있는 데이터

1. 클래스 정보 : 클래스, 메서드 등의 모든 실행 코드(바이트 코드)

2. static 변수

3. 런타임 상수 풀 : 공통 리터럴 상수

✅ 스택 영역

- 각 스택 프레임은 지역 변수, 메서드 호출 정보 등을 포함
- 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임은 제거됨
- 쓰레드마다 하나의 스택 영역이 있음

✅ 힙 영역

- 객체와 배열이 생성되는 영역
- GC가 이루어지는 주요 영역

✅ 메서드의 코드는 메서드 영역에 들어감

- 인스턴스마다 필드의 값은 다름 → 따라서 힙 영역
- 그러나 메서드의 코드는 동일하므로 → 메서드 영역으로 들어감
- 객체를 생성하면 필드는 메모리가 새로 할당되지만 메서드는 메모리가 새로 할당되지 않음(이미 메서드 영역에 있음)

# 2. 스택 영역

🤖 `JavaMemoryMain1`

- 메서드마다 스택 프레임이 생성됨
- 스택 프레임은 스택 영역에 들어감
- LIFO 구조로 동작

✅ 자바의 스택 영역

- 스택으로 메서드 호출과 지역 변수를 관리
- 지역 변수는 스택 영역에서 관리
- 스택 프레임이 종료되면 지역 변수도 함께 제거됨
- 스택 프레임이 모두 제거된면 프로그램도 종료

# 3. 스택 영역과 힙 영역

🤖 `JavaMemoryMain2`

- 메서드에서 객체를 사용한다면, 참조값으로 사용하는 것
- 따라서 메서드가 종료돼서 스택 프레임이 제거될 때 참조값이 제거되는 것(O), 해당 인스턴스가 제거되는 것(X)
- 참조되지 않는 인스턴스는 GC가 제거함(가비지 컬렉션)

✅ 정리

- 지역 변수 → 스택 영역
- 객체 → 힙 영역
- 메서드 영역에서 관리하는 변수는 static 키워드와 관련 있음

# 4. static 변수

✅ static 키워드는 주로 멤버 변수와 메서드에 사용

🤖 `DataCountMain1`

- 인스턴스를 생성할 때마다 멤버 변수도 같이 생성됨
- 따라서 전체 인스턴스의 개수를 세고 싶다면 단순한 멤버 변수만으로는 안됨
- 인스턴스끼리 공유할 수 있는 변수가 필요함

🤖 `DataCountMain2`

- 전체 인스턴스의 개수를 셀 수 있는 Counter라는 인스턴스 사용
- 단점 : Data 인스턴스의 개수를 세는 것인데, 다른 인스턴스를 사용함, 관련 있는 데이터는 같은 클래스에 있는게 좋음, 그리고 Counter 클래스 관련 코드가 추가되어야함

✅ static 키워드

- 특정 클래스에서 공용으로 사용할 수 있는 변수 생성

✅ static 변수

- = 정적 변수, 클래스 변수
- 멤버 변수 앞에 static 키워드가 붙은 변수
- 접근 : **`{클래스명}.`**
- 메서드 영역에서 관리

🤖 `DataCountMain3`

- static 변수를 사용

✅ 멤버 변수(필드)의 종류

1. 인스턴스 변수 : static이 붙지 않은 멤버 변수
    - 인스턴스를 생성해야 사용 가능
    - 인스턴스가 제거되면 같이 사라짐
2. 클래스 변수 : static이 붙은 멤버 변수
    - 인스턴스와 무관하게 클래스에 접근해서 사용 가능
    - 여러 인스턴스에서 공유할 목적

✅ 변수와 생명 주기

|  | 지역 변수
(매개 변수 포함) | 인스턴스 변수 | 클래스 변수 |
| --- | --- | --- | --- |
| 저장 영역 | 스택 영역(스택 프레임) | 힙 영역 | 메서드 영역(static 영역) |
| 생성 시기 | 메서드 실행 시 | 인스턴스 생성 시 | 클래스가 JVM에 로딩될 때 |
| 제거 시기 | 메서드 종료 시 | (참조되지 않아서) GC 발생 시 | JVM 종료 시 |

✅ static 단어의 의미

- 동적으로 힙 영역, 스택 영역에 생성되고 제거되는 변수와 다르므로 정적

✅ 정적 변수 접근법

1. 클래스를 통해 접근
2. 인스턴스를 통해 접근

🤖 `DataCountMain4`

- 인스턴스를 통해 접근 가능하지만 권장하지 않음
- ∵ 가독성이 떨어짐, 인스턴스 변수인지 클래스 변수인지 헷갈림

# 6. static 메서드

🤖 `DecoMain1`

- deco() 메서드 호출을 위해서 DecoUtil 인스턴스를 생성함
- 단점 : 인스턴스는 멤버 변수를 사용하는 목적이지만, 메서드만 호출해서 사용함

✅ static 메서드

- = 정적 메서드, 클래스 메서드
- 메서드에 static이 붙으면 정적 메서드가 됨
- 정적 메서드는 인스턴스 생성 없이 클래스명을 통해 바로 호출 가능
- ex. `DecoUtil2`

✅ 인스턴스 메서드

- static 키워드가 붙지 않은 메서드
- 인스턴스 메서드는 static 변수나 static 메서드 호출 가능

✅ 정적 메서드 사용법

- static 메서드는 static 변수나 static 메서드만 사용 가능

  → ∵ 인스턴스 변수/메서드의 생성이 보장되지 않으므로

  → 그리고 static 메서드는 인스턴스의 참조값을 몰라서(여러 인스턴스가 있다면 어떤 인스턴스인지 특정할 수도 없음) 접근 불가

- 모든 곳에서 static 호출 가능

  → 공용 기능이므로 클래스를 통해 모든 곳에서 static 호출 가능

  (접근 제어자 허용 범위 안에서)


⚠️ 주의 : 만약 static 메서드에 인스턴스의 참조값을 파라미터로 넣는다면 static 메서드도 인스턴스 변수나 메서드 호출 가능

- `public static void staticCall(DecoData data){ … }`
- 외부에서 파라미터로 인스턴스의 참조값이 들어가면 메서드 구현부에서 인스턴스에 접근 가능
- 내부의(같은 클래스의) 인스턴스 변수나 인스턴스 메서드에 접근하는 것이 안되는 것

✅ 용어 정리

- 멤버 메서드 = 클래스 내부에 정의된 메서드
- 인스턴스 메서드 = static이 붙지 않은 멤버 메서드
- 클래스 메서드(정적 메서드, static 메서드) = static이 붙은 멤버 메서드

✅ 정적 메서드의 활용

- 객체 생성 없이 메서드 호출만으로 기능을 수행하는 경우
- ex. 유틸리티성 메서드(파라미터만 받아서 로직 수행 후 반환하는 가능)

✅ 정적 메서드 접근법

- 클래스와 인스턴스를 통해서 둘 다 접근 가능
- ex. `data3.staticCall()`
- 그러나 가독성을 위해 인스턴스를 통한 접근은 X

✅ import static

- `DecoData.staticCall()` → `staticCall()`
- static 메서드/변수를 여러 번 사용할 때 매번 앞에 클래스명을 쓰면 코드가 반복됨
- 이때 import static을 사용하면 클래스명 없이 바로 static 메서드/변수 사용 가능

✅ main 메서드는 정적 메서드

- static 메서드는 static 메서드만 사용 가능
- 따라서 main 메서드 구현부의 메서드는 static 키워드가 붙음