# 섹션 2. 객체 지향 설계와 스프링

# 1. 자바 진영의 추운 겨울과 스프링의 탄생

### 📌 EJB가 주요 기술이던 시절(20년전)

- EJB(Enterprise JavaBeans) : 당시 자바 표준 기술
- 단점 : 설정이 복잡하고 어려움, 무겁고 느림, 비용이 비쌈

### 📌 스프링의 등장

- EJB의 복잡함을 해결하는 Spring Framework 등장
- EJB 컨테이너를 대체할 수 있는 경량 컨테이너
- EJB 없이도 확장 가능한 애플리케이션 개발이 가능해짐

### 📌 스프링이 표준처럼 자리잡은 이유

1. POJO(Plain Old Java Object) 개발 지원

- 단순한 자바 객체로도 개발 가능 → ∴ 테스트 용이성 ↑, 유지보수성 ↑

2. IoC, DI 같은 설계 철학

3. 경량 컨테이너 제공 : `BeanFactory`, `ApplicationContext`

- 개발자는 객체 관리에 대한 부담을 덜고 비즈니스 로직에 집중 가능

### 📌 하이버네이트와 JPA

- 스프링이 등장한 시기, EJB의 엔티티 빈(Entity Bean)도 문제가 많았음
- 이를 대체한 기술이 Hibernate
- 하이버네이트는 JPA(Java Persistence API)라는 표준 인터페이스를 따르게 됨
- 현재 대부분 JPA 구현체는 하이버네이트 기반

### 📌 스프링의 역사

- 2002년 스프링 저서 출간
- 스프링 이름은 EJB의 겨울을 끝내고 새로운 계절이 왔다는 의미

# 2. 스프링이란?

### 📌 스프링 생태계란

✅ 스프링은 단일 프레임워크가 아닌 여러 기술의 집합

- 필수 기술 : 스프링 프레임워크, 스프링 부트
- 선택 기술 : 스프링 데이터, 스프링 시큐리티, 스프링 배치 등

👉 스프링 프레임워크 : 스프링의 핵심 기능 제공

👉 스프링 부트 : 스프링 기술을 쉽게 활용할 수 있도록 지원하는 도구

### 📌 스프링 프레임워크 : 스프링 핵심 기술의 집합

✅ 핵심 기술

- DI 컨테이너 (의존성 주입)
- AOP (관심사 분리)
- 이벤트 처리, 메시지 등

✅ 웹 기술

- `Spring MVC`: 전통적인 요청-응답 기반 웹 애플리케이션
- `Spring WebFlux`

✅ 데이터 접근

- 트랜잭션 관리, JDBC, ORM (JPA 등), XML 설정 지원

✅ 기타 기술 통합

- 캐시, 이메일, 원격접근, 스케줄링 등 다양한 기능 지원

✅ 테스트

- 스프링 환경에서의 테스트 지원

✅ 언어 지원

- 자바 외에도 코틀린(Kotlin), 그루비(Groovy) 등 지원

### 📌 스프링 부트

✅ 스프링을 편하게 쓰기 위한 도구

- 단독 실행 가능한 애플리케이션 생성 지원
- 톰캣 등 웹 서버 내장 → ∴ 따로 설치 필요 없음
- `starter` 종속성 제공 → 의존성 관리가 간편함
- 스프링과 외부 라이브러리 자동 설정 (Auto Configuration)
- 프로덕션 환경 지원 기능 내장
    - 메트릭, 상태 확인, 외부 설정 관리 등
- 설정 파일이 간단하고 명확함

⚠️ 주의

- 스프링 부트는 스프링 프레임워크 없이 단독으로 사용할 수 없음
- 스프링 프레임워크 위에 올라가는 도구일뿐

### 📌 스프링이라는 단어의 다양한 의미

✅ 문맥에 따라 다르게 쓰임

- 좁은 의미: DI 컨테이너 기술 (ApplicationContext)
- 중간 의미: 스프링 프레임워크 전체
- 넓은 의미: 스프링 부트 포함, 스프링 생태계 전체

### 📌 스프링의 철학과 핵심 개념

✅ 스프링은 자바 언어의 객체 지향적 특성을 극대화하기 위해 탄생

- 자바는 객체 지향 언어지만, EJB는 그 철학을 제대로 반영 못함
    - ex. EJB는 특정 인터페이스 상속을 강요 → 유연성 ↓
- 스프링은 OOP 철학을 반영함
    - 스프링 IoC 컨테이너 → 객체 간 의존관계를 명확하게 분리

# 3. 좋은 객체 지향 프로그래밍이란

### 📌 객체 지향의 4대 특성

✅ OOP는 추상화, 캡슐화, 상속, 다형성을 기반으로 설계됨

- 추상화: 공통된 속성과 동작을 추출해 단순화
- 캡슐화: 데이터와 기능을 하나로 묶고 외부에 감춤
- 상속: 기존 클래스를 재사용하고 확장 가능
- 다형성: 동일한 인터페이스에 대해 다양한 구현 가능

### 📌 객체 지향 프로그래밍(OOP)의 개념

✅ OOP는 프로그램을 객체들의 협력 관계로 구성 → 유연성과 확장성을 높임

- 프로그램을 명령어 목록이 아닌 객체들의 집합으로 파악
- 객체는 메시지를 주고받고, 데이터를 스스로 처리
- 유연하고 확장성이 높으므로 → 대규모 SW 개발에 적합

✅ `유연하고 변경이 쉽다` 의미

- 프로그램의 구성요소를 레고처럼 교체하고 조립 가능
- 이런 유연함의 핵심은 다형성(Polymorphism)

### 📌 다형성의 실생활 비유: 운전자와 자동차

✅ 역할(인터페이스)과 구현(구현체)을 분리하면 ⇒ 클라이언트는 변경에 영향을 받지 않음

- 운전자는 자동차의 역할만 알면 되고, 구현(K3, 아반떼 등)은 몰라도 됨
- 자동차를 교체해도 운전 방법은 동일
- 자동차 인터페이스(예: 핸들, 브레이크)를 기준으로 학습 → 자동차마다 면허 따로 필요 없음
- 자동차의 내부 구현은 변경 가능하지만, 운전자에게 영향 없음

### 📌 역할과 구현을 분리할 때의 장점

✅ 역할(인터페이스)만 알면 구현이 바뀌어도 영향을 받지 않음

- 구조가 단순해지고 유연해짐
- 클라이언트는 대상의 구현 세부 사항을 몰라도 됨
- 구현 내부가 변경되거나, 구현 자체가 바뀌어도 클라이언트는 그대로 사용 가능

### 📌 자바에서 역할과 구현 분리하기

✅ 자바에서는 인터페이스와 구현 클래스를 통해 역할과 구현을 구분할 수 있음

- 역할: `interface`
- 구현: `implements` 키워드를 이용한 클래스
- 객체 설계 시 역할부터 정의하고, 나중에 구현체 설계
- 다형성을 통해 유연한 구조 설계 가능

### 📌 객체의 협력 구조 중심의 사고

✅ 객체는 혼자 존재하지 않고, 서로 협력하는 구조로 시스템을 이룸

- 클라이언트와 서버 역할로 역할 분담
- 객체 간 협력(메세지 흐름)을 중심으로 설계해야함

### 📌 자바 언어에서의 다형성 구현

✅ 오버라이딩과 실행 시점의 객체 결정으로 ⇒ 유연한 기능 확장이 가능함

- 자바는 기본 문법으로 메서드 오버라이딩을 제공
- 런타임 시점에 어떤 구현 객체가 실행될지는 동적으로 결정
- 이를 통해 클라이언트는 동일한 코드로 다양한 기능 수행 가능

### 📌 다형성의 본질

✅ 다형성 때문에 객체 간 협력 관계에서 유연한 구조가 가능

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 교체 가능
- 다형성을 이해하려면 단순한 문법이 아닌, 클라이언트-서버 간 협력 관계로부터 출발해야 함
- 클라이언트를 변경하지 않고도 서버(구현체)의 기능을 쉽게 확장하거나 교체 가능

### 📌 역할과 구현을 분리

✅ 인터페이스를 통한 역할/구현 분리 ⇒ ∴ 변경에 유연하고, 확장 가능한 설계를 가능

- 유연하고 변경이 쉬운 구조
- 새로운 기능이나 구현을 추가해도 기존 클라이언트에 영향 없음
- ∴ 인터페이스를 중심으로 한 설계는 시스템의 확장성과 유지보수성을 높임

✅ 하지만 역할(인터페이스) 자체가 변경되면 클라이언트와 서버 모두에 영향

- 인터페이스가 바뀌면, 그걸 사용하는 클라이언트 코드도 함께 수정해야 함
- ∴ 처음부터 인터페이스를 안정적으로 잘 설계하는 것이 매우 중요

### 📌 스프링과 객체 지향

✅ 스프링은 객체 지향의 핵심인 다형성을 최대한 활용할 수 있도록 지원

- 스프링의 핵심 철학은 다형성을 기반으로 한 유연한 설계
- IoC (제어의 역전), DI (의존관계 주입)는 다형성을 전제로 작동
- 이를 통해 역할(인터페이스)과 구현체를 편리하게 다룰 수 있게 됨
- 구현 객체의 교체가 간편해지고, 코드의 변경 없이도 다양한 기능을 주입 가능

# 4. 좋은 객체 지향 설계의 5가지 원칙(SOLID)

### 📌 SOLID

✅ 로버트 마틴이 정리한, 객체 지향 설계의 다섯 가지 핵심 원칙

- SRP: 단일 책임 원칙 (Single Responsibility Principle)
- OCP: 개방-폐쇄 원칙 (Open-Closed Principle)
- LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)
- ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)
- DIP: 의존관계 역전 원칙 (Dependency Inversion Principle)

### 📌 SRP: 단일 책임 원칙

✅ 하나의 클래스는 오직 하나의 책임만 가져야 함

- 책임의 범위는 상황과 문맥에 따라 크고 작게 나뉘며 판단이 모호할 수 있음
- 책임을 너무 작게 나누면 오히려 복잡해지고, 너무 크게 하면 변경이 어려움
- ∴ SRP를 잘 지키고 있는지 판단하는 기준 : 변경이 생겼을 때 파급 효과가 작은가?

### 📌 OCP: 개방-폐쇄 원칙

✅ SW는 확장에는 열려 있고, 변경에는 닫혀 있어야 함

- 코드를 변경하지 않고도 기능을 확장할 수 있어야 함
- 다형성을 활용하여 인터페이스를 구현한 새 클래스를 추가하는 방식으로 확장

🤖 예시

- 클라이언트 코드(Memberservice)가 구현체를 직접 선택하는 구조는 OCP 위반

```java
MemberRepository m = new MemoryMemberRepository(); // 기존
MemberRepository m = new JdbcMemberRepository();   // 변경
```

✅ 해결 방법: 객체 생성 및 연결은 별도의 설정자가 처리해야 함

- 이를 스프링에서 DI, IoC 컨테이너로 해결

### 📌 LSP: 리스코프 치환 원칙

✅ 하위 타입은 상위 타입을 대체하더라도 프로그램의 정확성이 유지되어야 함

- 다형성을 지원하기 위한 핵심 원칙
- 인터페이스를 구현한 클래스는 규약을 반드시 지켜야 함

✅ 예시

- 자동차 인터페이스의 `엑셀()` → "앞으로 가라"는 규약
- 이때, 어떤 구현체가 엑셀을 눌렀을 때 뒤로 간다면 → LSP 위반

✅ LSP를 위반해도 컴파일은 성공함, 그러나 기능적 의미도 일관성 있게 구현해야 함

### 📌 ISP: 인터페이스 분리 원칙

✅ 범용적인 인터페이스 하나보다, 클라이언트에 특화된 여러 개의 작은 인터페이스로 분리

✅ 예시

- 자동차 인터페이스를 운전용 / 정비용으로 분리하면 → 클라이언트도 운전자/정비사로 분리 가능
- 그러면 한 인터페이스에 변경점이 생겨도 다른 클라이언트에 영향 없음
- 그리고 인터페이스가 작으면 구현이 쉬워지고 대체 가능성도 높아짐

✅ 스프링 내부 코드도 철저하게 이 원칙을 따름

### 📌 DIP: 의존관계 역전 원칙

✅ 프로그래머는 추상화(인터페이스)에 의존해야지, 구체화(구현 클래스)에 의존하면 안됨

- 의존성 주입(DI)은 DIP를 실현하는 방식 중 하나

✅ 이유

- 인터페이스에 의존하면 구현체를 유연하게 교체 가능
- 구현체에 직접 의존하면, 변경 시 클라이언트 코드도 변경 필요

✅ DIP 위반 예시

- MemberService 클라이언트가 구현 클래스를 직접 선택하고 있으므로 DIP 위반

```java
MemberRepository m = new MemoryMemberRepository();
```

💡 참고

- `의존한다 == 해당 코드(클래스)가 내부 코드로 있다`

### 📌 정리

✅ 객체 지향의 핵심은 다형성이지만, 그것만으로는 부족함

- 다형성만 사용하면, 구현된 객체를 변경할 때 이에 따라 클라이언트 코드도 함께 변경됨
- 다형성만으로는 OCP, DIP를 지킬 수 없음

# 5. 객체 지향 설계와 스프링

### 📌 스프링과 객체 지향의 연관성

✅ 스프링은 OCP, DIP 같은 객체 지향 설계 원칙을 실현하도록 도와주는 프레임워크

- DI(의존관계 주입)와 IoC 컨테이너를 통해 역할과 구현을 유연하게 연결
- 클라이언트 코드를 변경하지 않고도 구현체를 갈아끼우듯 교체 가능

### 📌 스프링 없던 시절

✅ 스프링 없이 OCP, DIP 원칙을 지키려면 개발자가 직접 많은 설정을 해야 했음

- 객체 생성, 연결, 의존성 주입 등을 수동으로 관리해야 했음
- 코드 양이 많아지고, 변경이 불편 → 생산성 저하
- 결국 이런 불편함을 줄이기 위해 사람들이 만든 것이 DI 컨테이너, 즉 스프링 프레임워크

### 📌 정리: 객체 지향 설계와 스프링 철학

✅ 좋은 설계란 역할과 구현을 분리하고, 유연하게 확장 가능한 구조를 만드는 것

- 모든 설계에서 역할(인터페이스)과 구현(클래스)을 분리하는 것이 이상적
- 객체를 유연하게 변경 가능해야 좋은 설계
- 인터페이스를 부여하면 변경과 확장이 쉬움 → 미래의 변화를 대비할 수 있음

⚠️ 실무에서의 고민: 추상화는 공짜가 아님

- 추상화에는 비용이 따름
- ex. 인터페이스를 도입하면 설계가 복잡해지고 관리할 대상이 늘어남
- 기능이 단순하고 확장 가능성이 거의 없는 경우엔 굳이 추상화할 필요 없음

✅ 실무적 조언

- 처음엔 구체 클래스로 간단히 개발
- 나중에 확장/변경 필요 시점에 인터페이스로 리팩터링하는 방식도 유효